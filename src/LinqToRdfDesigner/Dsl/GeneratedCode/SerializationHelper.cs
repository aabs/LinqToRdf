//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace LinqToRdf.Designer
{
	/// <summary>
	/// Partial class to handle serialization of ModelRoot instance as a root-level XML element.
	/// </summary>
	public partial class ModelRootSerializer
	{
		/// <summary>
		/// Public ReadRootElement() method that deserializes a root-level ModelRoot instance from XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="schemaResolver">An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).</param>
		public override void ReadRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader, DslModeling::ISchemaResolver schemaResolver)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
	
			// Version check.
			CheckVersion(serializationContext, reader);
	
			if (!serializationContext.Result.Failed)
			{	// Check to see if schema validation is possible.
				if (schemaResolver != null)
				{
					string targetNamespace = reader.NamespaceURI;
					if (!string.IsNullOrEmpty(targetNamespace))
					{
						global::System.Collections.Generic.IList<string> schemas = schemaResolver.ResolveSchema(targetNamespace);
						if (schemas != null && schemas.Count > 0)
						{
							if (schemas.Count > 1)
							{
								LinqToRdfDesignerSerializationBehaviorSerializationMessages.AmbiguousSchema(serializationContext, reader, targetNamespace, schemas[0]);
							}
							global::System.Xml.Schema.XmlSchemaSet schemaSet = new global::System.Xml.Schema.XmlSchemaSet(reader.NameTable);
							schemaSet.Add(targetNamespace, schemas[0]);
							global::System.Xml.XmlReaderSettings readerSettings = new global::System.Xml.XmlReaderSettings();
							readerSettings.ConformanceLevel = global::System.Xml.ConformanceLevel.Auto;
							readerSettings.ValidationType = global::System.Xml.ValidationType.Schema;
							readerSettings.Schemas = schemaSet;
							LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback validationCallback = new LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback(serializationContext);
							readerSettings.ValidationEventHandler += new global::System.Xml.Schema.ValidationEventHandler(validationCallback.Handler);
							// Wrap the given reader as a validating reader and carry out the normal deserialization.
							using (global::System.Xml.XmlReader validatingReader = global::System.Xml.XmlReader.Create(reader, readerSettings))
							{
								validationCallback.Reader = validatingReader;
								this.Read(serializationContext, element, validatingReader);
							}
							return;
						}
						else
						{
							LinqToRdfDesignerSerializationBehaviorSerializationMessages.NoSchema(serializationContext, reader, targetNamespace);
						}
					}
				}
	
				// No schema information available, carry out the normal deserialization.
				this.Read(serializationContext, element, reader);
			}
		}
		
		/// <summary>
		/// Checks the version of the file being read.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">Reader for the file being read. The reader is positioned at the open tag of the root element being read.</param>
		private static void CheckVersion(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			global::System.Version expectedVersion = new global::System.Version("1.0.0.0");
			string dslVersionStr = reader.GetAttribute("dslVersion");
			if (dslVersionStr != null)
			{
				try
				{
					global::System.Version actualVersion = new global::System.Version(dslVersionStr);
					if (actualVersion != expectedVersion)
					{
						LinqToRdfDesignerSerializationBehaviorSerializationMessages.VersionMismatch(serializationContext, reader, expectedVersion, actualVersion);
					}
				}
				catch (global::System.ArgumentException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
				catch (global::System.FormatException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
				catch (global::System.OverflowException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
			}
		}
		
		/// <summary>
		/// A utility class to handle schema validation warning/error
		/// </summary>
		private sealed class LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback
		{
			#region Member Variables
			/// <summary>
			/// SerializationContext to store schema validation warning/error.
			/// </summary>
			DslModeling::SerializationContext serializationContext;
			/// <summary>
			/// Reader that generates the schema warning/error.
			/// </summary>
			global::System.Xml.XmlReader reader;
			#endregion
	
			#region Constructor
			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="serializationContext">SerializationContext to be used to store schema validation warning/error.</param>
			internal LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback(DslModeling::SerializationContext serializationContext)
			{
				global::System.Diagnostics.Debug.Assert(serializationContext != null);
				this.serializationContext = serializationContext;
			}
			#endregion
	
			#region Accessor
			/// <summary>
			/// Sets the reader that generates the schema validation warning/error.
			/// </summary>
			internal global::System.Xml.XmlReader Reader
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				set { this.reader = value; }
			}
			#endregion
	
			#region Callback method
			/// <summary>
			/// Callback to handler schema validation warning/error.
			/// </summary>
			internal void Handler(object sender, global::System.Xml.Schema.ValidationEventArgs e)
			{
				global::System.Diagnostics.Debug.Assert(this.serializationContext != null);
				if (this.serializationContext != null)
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.SchemaValidationError(this.serializationContext, this.reader, e.Message);
			}
			#endregion
		}
	
		/// <summary>
		/// Public WriteRootElement() method that serializes a root-level ModelRoot instance to XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRoot instance that will be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		public override void WriteRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			global::System.Diagnostics.Debug.Assert(writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException("writer");
			#endregion
	
			// Set up root element settings
			DslModeling::RootElementSettings rootElementSettings = new DslModeling::RootElementSettings();
			rootElementSettings.SchemaTargetNamespace = "http://schemas.microsoft.com/dsltools/LinqToRdfDesigner";
			rootElementSettings.Version = new global::System.Version("1.0.0.0");
	
			// Carry out the normal serialization.
			this.Write(serializationContext, element, writer, rootElementSettings);
		}
	}
}

namespace LinqToRdf.Designer
{
	/// <summary>
	/// Partial class to handle serialization of ClassDiagram instance as a root-level XML element.
	/// </summary>
	public partial class ClassDiagramSerializer
	{
		/// <summary>
		/// Public ReadRootElement() method that deserializes a root-level ClassDiagram instance from XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="schemaResolver">An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).</param>
		public override void ReadRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader, DslModeling::ISchemaResolver schemaResolver)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
	
			// Version check.
			CheckVersion(serializationContext, reader);
	
			if (!serializationContext.Result.Failed)
			{	// Check to see if schema validation is possible.
				if (schemaResolver != null)
				{
					string targetNamespace = reader.NamespaceURI;
					if (!string.IsNullOrEmpty(targetNamespace))
					{
						global::System.Collections.Generic.IList<string> schemas = schemaResolver.ResolveSchema(targetNamespace);
						if (schemas != null && schemas.Count > 0)
						{
							if (schemas.Count > 1)
							{
								LinqToRdfDesignerSerializationBehaviorSerializationMessages.AmbiguousSchema(serializationContext, reader, targetNamespace, schemas[0]);
							}
							global::System.Xml.Schema.XmlSchemaSet schemaSet = new global::System.Xml.Schema.XmlSchemaSet(reader.NameTable);
							schemaSet.Add(targetNamespace, schemas[0]);
							global::System.Xml.XmlReaderSettings readerSettings = new global::System.Xml.XmlReaderSettings();
							readerSettings.ConformanceLevel = global::System.Xml.ConformanceLevel.Auto;
							readerSettings.ValidationType = global::System.Xml.ValidationType.Schema;
							readerSettings.Schemas = schemaSet;
							LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback validationCallback = new LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback(serializationContext);
							readerSettings.ValidationEventHandler += new global::System.Xml.Schema.ValidationEventHandler(validationCallback.Handler);
							// Wrap the given reader as a validating reader and carry out the normal deserialization.
							using (global::System.Xml.XmlReader validatingReader = global::System.Xml.XmlReader.Create(reader, readerSettings))
							{
								validationCallback.Reader = validatingReader;
								this.Read(serializationContext, element, validatingReader);
							}
							return;
						}
						else
						{
							LinqToRdfDesignerSerializationBehaviorSerializationMessages.NoSchema(serializationContext, reader, targetNamespace);
						}
					}
				}
	
				// No schema information available, carry out the normal deserialization.
				this.Read(serializationContext, element, reader);
			}
		}
		
		/// <summary>
		/// Checks the version of the file being read.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">Reader for the file being read. The reader is positioned at the open tag of the root element being read.</param>
		private static void CheckVersion(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			global::System.Version expectedVersion = new global::System.Version("1.0.0.0");
			string dslVersionStr = reader.GetAttribute("dslVersion");
			if (dslVersionStr != null)
			{
				try
				{
					global::System.Version actualVersion = new global::System.Version(dslVersionStr);
					if (actualVersion != expectedVersion)
					{
						LinqToRdfDesignerSerializationBehaviorSerializationMessages.VersionMismatch(serializationContext, reader, expectedVersion, actualVersion);
					}
				}
				catch (global::System.ArgumentException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
				catch (global::System.FormatException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
				catch (global::System.OverflowException)
				{
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
				}
			}
		}
		
		/// <summary>
		/// A utility class to handle schema validation warning/error
		/// </summary>
		private sealed class LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback
		{
			#region Member Variables
			/// <summary>
			/// SerializationContext to store schema validation warning/error.
			/// </summary>
			DslModeling::SerializationContext serializationContext;
			/// <summary>
			/// Reader that generates the schema warning/error.
			/// </summary>
			global::System.Xml.XmlReader reader;
			#endregion
	
			#region Constructor
			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="serializationContext">SerializationContext to be used to store schema validation warning/error.</param>
			internal LinqToRdfDesignerSerializationBehaviorSchemaValidationCallback(DslModeling::SerializationContext serializationContext)
			{
				global::System.Diagnostics.Debug.Assert(serializationContext != null);
				this.serializationContext = serializationContext;
			}
			#endregion
	
			#region Accessor
			/// <summary>
			/// Sets the reader that generates the schema validation warning/error.
			/// </summary>
			internal global::System.Xml.XmlReader Reader
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				set { this.reader = value; }
			}
			#endregion
	
			#region Callback method
			/// <summary>
			/// Callback to handler schema validation warning/error.
			/// </summary>
			internal void Handler(object sender, global::System.Xml.Schema.ValidationEventArgs e)
			{
				global::System.Diagnostics.Debug.Assert(this.serializationContext != null);
				if (this.serializationContext != null)
					LinqToRdfDesignerSerializationBehaviorSerializationMessages.SchemaValidationError(this.serializationContext, this.reader, e.Message);
			}
			#endregion
		}
	
		/// <summary>
		/// Public WriteRootElement() method that serializes a root-level ClassDiagram instance to XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassDiagram instance that will be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		public override void WriteRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			global::System.Diagnostics.Debug.Assert(writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException("writer");
			#endregion
	
			// Set up root element settings
			DslModeling::RootElementSettings rootElementSettings = new DslModeling::RootElementSettings();
			rootElementSettings.Version = new global::System.Version("1.0.0.0");
	
			// Carry out the normal serialization.
			this.Write(serializationContext, element, writer, rootElementSettings);
		}
	}
}

namespace LinqToRdf.Designer
{
	/// <summary>
	/// Helper class for serializing and deserializing LinqToRdfDesigner models.
	/// </summary>
	public abstract partial class LinqToRdfDesignerSerializationHelperBase
	{
		#region Constructor
		/// <summary>
		/// Constructor
		/// </summary>
		protected LinqToRdfDesignerSerializationHelperBase() { }
		#endregion
	
		/// <summary>
		/// Loads a ModelRoot instance into the default partition of the given store, and ignore serialization result.
		/// </summary>
		/// <param name="store">The new ModelRoot instance will be created into the default partition of this store.</param>
		/// <param name="fileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual ModelRoot LoadModel(DslModeling::Store store, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			if (store == null) 
				throw new global::System.ArgumentNullException("store");
			#endregion
			
			return this.LoadModel(new DslModeling::SerializationResult(), store.DefaultPartition, fileName, schemaResolver, validationController);
		}
		
		/// <summary>
		/// Loads a ModelRoot instance into the default partition of the given store.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="store">The new ModelRoot instance will be created into the default partition of this store.</param>
		/// <param name="fileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual ModelRoot LoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Store store, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			if (store == null) 
				throw new global::System.ArgumentNullException("store");
			#endregion
			
			return this.LoadModel(serializationResult, store.DefaultPartition, fileName, schemaResolver, validationController);
		}
	
		/// <summary>
		/// Loads a ModelRoot instance.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="fileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual ModelRoot LoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Partition partition, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			if (partition == null)
				throw new global::System.ArgumentNullException("partition");
			if (string.IsNullOrEmpty(fileName))
				throw new global::System.ArgumentNullException("fileName");
			#endregion
		
			// Ensure there is a transaction for this model to Load in.
			if (!partition.Store.TransactionActive)
			{
				throw new global::System.InvalidOperationException(LinqToRdfDesignerDomainModel.SingletonResourceManager.GetString("MissingTransaction"));
			}
			
			ModelRoot modelRoot = null;
			DslModeling::DomainClassXmlSerializer modelRootSerializer = this.Directory.GetSerializer(ModelRoot.DomainClassId);
			global::System.Diagnostics.Debug.Assert(modelRootSerializer != null, "Cannot find serializer for ModelRoot!");
			if (modelRootSerializer != null)
			{
				using (global::System.IO.FileStream fileStream = global::System.IO.File.OpenRead(fileName))
				{
					using (DslModeling::Transaction t = partition.Store.TransactionManager.BeginTransaction("Load Model from " + fileName, true))
					{
						DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(this.Directory, fileStream.Name, serializationResult);
						// Set up MonikerResolver for LinqToRdfDesigner.
						this.SetupMonikerResolver(serializationContext, partition.Store);
						// Ensure there is some content in the file.  Blank (or almost blank, to account for encoding header bytes, etc.)
						// files will cause a new root element to be created and returned. 
						if (fileStream.Length > 5)
						{
							global::System.Xml.XmlReaderSettings settings = new global::System.Xml.XmlReaderSettings();
							try
							{
								using (global::System.Xml.XmlReader reader = global::System.Xml.XmlReader.Create(fileStream, settings))
								{
									reader.MoveToContent();
									modelRoot = modelRootSerializer.TryCreateInstance(serializationContext, reader, partition) as ModelRoot;
									if (modelRoot != null && !serializationResult.Failed)
									{
										// Note: the actual instance we get back from TryCreateInstance() can be of a derived type of ModelRoot,
										// so we need to find the correct serializer instance to deserialize the element properly.
										DslModeling::DomainClassXmlSerializer instanceSerializer = this.Directory.GetSerializer(modelRoot.GetDomainClass().Id);
										global::System.Diagnostics.Debug.Assert(instanceSerializer != null, "Cannot find serializer for " + modelRoot.GetDomainClass().Name + "!");
										instanceSerializer.ReadRootElement(serializationContext, modelRoot, reader, schemaResolver);
									}
								}
	
							}
							catch (global::System.Xml.XmlException xEx)
							{
								DslModeling::SerializationUtilities.AddMessage(
									serializationContext,
									DslModeling::SerializationMessageKind.Error,
									xEx
								);
							}
						}
				
						if(modelRoot == null && !serializationResult.Failed)
						{
							// create model root if it doesn't exist.
							modelRoot = this.CreateModelHelper(partition);
						}
						if (t.IsActive)
							t.Commit();
					} // End Inner Tx
	
					// Do load-time validation if a ValidationController is provided.
					if (!serializationResult.Failed && validationController != null)
					{
						using (new SerializationValidationObserver(serializationResult, validationController))
						{
							validationController.Validate(partition, DslValidation::ValidationCategories.Load);
						}
					}
				}
			}
			return modelRoot;
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with default encoding (UTF-8), and optional properties with default value will not
		/// be written out.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		public virtual void SaveModel(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string fileName)
		{
			this.SaveModel(serializationResult, modelRoot, fileName, global::System.Text.Encoding.UTF8, false);
		}
		
		/// <summary>
		/// Saves the given model to the given file, with default encoding (UTF-8).
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		public virtual void SaveModel(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string fileName, bool writeOptionalPropertiesWithDefaultValue)
		{
			this.SaveModel(serializationResult, modelRoot, fileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the ModelRoot instance.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		public virtual void SaveModel(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string fileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
		{
			#region Check Parameters
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			if (modelRoot == null)
				throw new global::System.ArgumentNullException("modelRoot");
			if (string.IsNullOrEmpty(fileName))
				throw new global::System.ArgumentNullException("fileName");
			#endregion
	
			if (serializationResult.Failed)
				return;
	
			using (global::System.IO.MemoryStream newFileContent = this.InternalSaveModel(serializationResult, modelRoot, fileName, encoding, writeOptionalPropertiesWithDefaultValue))
			{
				if (!serializationResult.Failed && newFileContent != null)
				{	// Only write the content if there's no error encountered during serialization.
					using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(fileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
					{
						using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
						{
							writer.Write(newFileContent.ToArray());
						}
					}
				}
			}
		}
	
		/// <summary>
		/// Saves the given model root as a in-memory stream.
		/// This is a helper used by SaveModel() and SaveModelAndDiagram(). When saving the model and the diagram together, we want to make sure that 
		/// both can be saved without error before writing the content to disk, so we serialize the model into a in-memory stream first.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the ModelRoot instance.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		/// <returns>In-memory stream containing the serialized ModelRoot instance.</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		private global::System.IO.MemoryStream InternalSaveModel(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string fileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			global::System.Diagnostics.Debug.Assert(modelRoot != null);
			global::System.Diagnostics.Debug.Assert(!serializationResult.Failed);
			#endregion
			
			global::System.IO.MemoryStream newFileContent = new global::System.IO.MemoryStream();
			
			DslModeling::DomainClassXmlSerializer modelRootSerializer = this.Directory.GetSerializer(modelRoot.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(modelRootSerializer != null, "Cannot find serializer for " + modelRoot.GetDomainClass().Name + "!");
			if (modelRootSerializer != null)
			{
				DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(this.Directory, fileName, serializationResult);
				// MonikerResolver shouldn't be required in Save operation, so not calling SetupMonikerResolver() here.
				serializationContext.WriteOptionalPropertiesWithDefaultValue = writeOptionalPropertiesWithDefaultValue;
				global::System.Xml.XmlWriterSettings settings = new global::System.Xml.XmlWriterSettings();
				settings.Indent = true;
				settings.Encoding = encoding;
				using (global::System.IO.StreamWriter streamWriter = new global::System.IO.StreamWriter(newFileContent, encoding))
				{
					using (global::System.Xml.XmlWriter writer = global::System.Xml.XmlWriter.Create(streamWriter, settings))
					{
						modelRootSerializer.WriteRootElement(serializationContext, modelRoot, writer);
					}
				}
			}
			return newFileContent;
		}
		/// <summary>
		/// Saves the given model root as a in-memory stream.
		/// This is a helper used by SaveModel() and SaveModelAndDiagram(). When saving the model and the diagram together, we want to make sure that 
		/// both can be saved without error before writing the content to disk, so we serialize the model into a in-memory stream first.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		/// <returns>In-memory stream containing the serialized ClassDiagram instance.</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		private global::System.IO.MemoryStream InternalSaveDiagram(DslModeling::SerializationResult serializationResult, ClassDiagram diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			global::System.Diagnostics.Debug.Assert(diagram != null);
			global::System.Diagnostics.Debug.Assert(!serializationResult.Failed);
			#endregion
			
			global::System.IO.MemoryStream newFileContent = new global::System.IO.MemoryStream();
			
			DslModeling::DomainClassXmlSerializer diagramSerializer = this.Directory.GetSerializer(diagram.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(diagramSerializer != null, "Cannot find serializer for " + diagram.GetDomainClass().Name + "!");
			if (diagramSerializer != null)
			{
				DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(this.Directory, diagramFileName, serializationResult);
				// MonikerResolver shouldn't be required in Save operation, so not calling SetupMonikerResolver() here.
				serializationContext.WriteOptionalPropertiesWithDefaultValue = writeOptionalPropertiesWithDefaultValue;
				global::System.Xml.XmlWriterSettings settings = new global::System.Xml.XmlWriterSettings();
				settings.Indent = true;
				settings.Encoding = encoding;
				using (global::System.IO.StreamWriter streamWriter = new global::System.IO.StreamWriter(newFileContent, encoding))
				{
					using (global::System.Xml.XmlWriter writer = global::System.Xml.XmlWriter.Create(streamWriter, settings))
					{
						diagramSerializer.WriteRootElement(serializationContext, diagram, writer);
					}
				}
			}
			return newFileContent;
		}
	
		/// <summary>
		/// Helper method to create and initialize a new ModelRoot.
		/// </summary>
		internal protected virtual ModelRoot CreateModelHelper(DslModeling::Partition modelPartition)
		{
			ModelRoot model = new ModelRoot(modelPartition);
			return model;
		}
		
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file into the default partition of the given store, and ignore serialization result.
		/// </summary>
		/// <param name="store">The new ModelRoot instance will be created into the default partition of this store.</param>
		/// <param name="modelFileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="diagramFileName">Name of the file from which the ClassDiagram instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual ModelRoot LoadModelAndDiagram(DslModeling::Store store, string modelFileName, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			return this.LoadModelAndDiagram(new DslModeling::SerializationResult(), store, modelFileName, diagramFileName, schemaResolver, validationController);
		}
		
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file into the default partition of the given store.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="store">The new ModelRoot instance will be created into the default partition of this store.</param>
		/// <param name="modelFileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="diagramFileName">Name of the file from which the ClassDiagram instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual ModelRoot LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, DslModeling::Store store, string modelFileName, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			if (store == null)
				throw new global::System.ArgumentNullException("store");
			#endregion
			
			return this.LoadModelAndDiagram(serializationResult, store.DefaultPartition, modelFileName, store.DefaultPartition, diagramFileName, schemaResolver, validationController);
		}
			
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new ClassDiagram instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the ClassDiagram instance will be deserialized.</param>
		/// <param name="schemaResolver">
		/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
		/// If null is passed, schema validation will not be performed.
		/// </param>
		/// <param name="validationController">
		/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
		/// is passed, load-time validation will not be performed.
		/// </param>
		/// <returns>The loaded ModelRoot instance.</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
		public virtual ModelRoot LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, DslModeling::Partition modelPartition, string modelFileName, DslModeling::Partition diagramPartition, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			if (modelPartition == null)		
				throw new global::System.ArgumentNullException("modelPartition");
			if (diagramPartition == null)
				throw new global::System.ArgumentNullException("diagramPartition");
			if (string.IsNullOrEmpty(diagramFileName))
				throw new global::System.ArgumentNullException("diagramFileName");
			#endregion
	
			ModelRoot modelRoot;
	
			// Ensure there is an outer transaction spanning both model and diagram load, so moniker resolution works properly.
			if (!diagramPartition.Store.TransactionActive)
			{
				throw new global::System.InvalidOperationException(LinqToRdfDesignerDomainModel.SingletonResourceManager.GetString("MissingTransaction"));
			}
	
			modelRoot = this.LoadModel(serializationResult, modelPartition, modelFileName, schemaResolver, validationController);
	
			if (serializationResult.Failed)
			{
				// don't try to deserialize diagram data if model load failed.
				return modelRoot;
			}
	
			ClassDiagram diagram = null;
			DslModeling::DomainClassXmlSerializer diagramSerializer = this.Directory.GetSerializer(ClassDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(diagramSerializer != null, "Cannot find serializer for ClassDiagram");
			if (diagramSerializer != null)
			{
				if(!global::System.IO.File.Exists(diagramFileName))
				{
					// missing diagram file indicates we should create a new diagram.
					diagram = this.CreateDiagramHelper(diagramPartition, modelRoot);
				}
				else
				{
					using (global::System.IO.FileStream fileStream = global::System.IO.File.OpenRead(diagramFileName))
					{
						DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(this.Directory, fileStream.Name, serializationResult);
						// Set up MonikerResolver for LinqToRdfDesigner.
						this.SetupMonikerResolver(serializationContext, diagramPartition.Store);
						
						using (DslModeling::Transaction t = diagramPartition.Store.TransactionManager.BeginTransaction("LoadDiagram", true))
						{
							// Ensure there is some content in the file. Blank (or almost blank, to account for encoding header bytes, etc.)
							// files will cause a new diagram to be created and returned 
							if (fileStream.Length > 5)
							{
								global::System.Xml.XmlReaderSettings settings = new global::System.Xml.XmlReaderSettings();
								try
								{
									using (global::System.Xml.XmlReader reader = global::System.Xml.XmlReader.Create(fileStream, settings))
									{
										reader.MoveToContent();
										diagram = diagramSerializer.TryCreateInstance(serializationContext, reader, diagramPartition) as ClassDiagram;
										if (diagram != null)
										{
											// Note: the actual instance we get back from TryCreateInstance() can be of a derived type of ClassDiagram,
											// so we need to find the correct serializer instance to deserialize the element properly.
											DslModeling::DomainClassXmlSerializer instanceSerializer = this.Directory.GetSerializer(diagram.GetDomainClass().Id);
											global::System.Diagnostics.Debug.Assert(instanceSerializer != null, "Cannot find serializer for " + diagram.GetDomainClass().Name + "!");
											instanceSerializer.ReadRootElement(serializationContext, diagram, reader, schemaResolver);
										}
									}
								}
								catch (global::System.Xml.XmlException xEx)
								{
									DslModeling::SerializationUtilities.AddMessage(
										serializationContext,
										DslModeling::SerializationMessageKind.Error,
										xEx
									);
								}
								if (serializationResult.Failed)
								{	
									// Serialization error encountered, rollback the transaction.
									diagram = null;
									t.Rollback();
								}
							}
							
							if(diagram == null && !serializationResult.Failed)
							{
								// Create diagram if it doesn't exist
								diagram = this.CreateDiagramHelper(diagramPartition, modelRoot);
							}
							
							if (t.IsActive)
								t.Commit();
						} // End inner Tx
	
						// Do load-time validation if a ValidationController is provided.
						if (!serializationResult.Failed && validationController != null)
						{
							using (new SerializationValidationObserver(serializationResult, validationController))
							{
								validationController.Validate(diagramPartition, DslValidation::ValidationCategories.Load);
							}
						}
					}
				}
	
				if (diagram != null)
				{
					if (!serializationResult.Failed)
					{	// Succeeded.
						diagram.ModelElement = modelRoot;
						diagram.PostDeserialization(true);
						this.CheckForOrphanedShapes(diagram, serializationResult);
					}
					else
					{	// Failed.
						diagram.PostDeserialization(false);
					}
				}
			}
			return modelRoot;
		}
	
		/// <summary>
		/// Helper method to create and initialize a new ClassDiagram.
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="modelRoot", Justification = "Signature enforced by caller.")]
		internal protected virtual ClassDiagram CreateDiagramHelper(DslModeling::Partition diagramPartition, DslModeling::ModelElement modelRoot)
		{
			ClassDiagram diagram = new ClassDiagram(diagramPartition);
			return diagram;
		}
	
		/// <summary>
		/// Saves the given diagram to the given file, with default encoding (UTF-8), and optional properties with default value will not
		/// be written out.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		public virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string modelFileName, ClassDiagram diagram, string diagramFileName)
		{
			this.SaveModelAndDiagram(serializationResult, modelRoot, modelFileName, diagram, diagramFileName, global::System.Text.Encoding.UTF8, false);
		}
		
		/// <summary>
		/// Saves the given diagram to the given file, with default encoding (UTF-8).
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		public virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string modelFileName, ClassDiagram diagram, string diagramFileName, bool writeOptionalPropertiesWithDefaultValue)
		{
			this.SaveModelAndDiagram(serializationResult, modelRoot, modelFileName, diagram, diagramFileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
		}
	
		/// <summary>
		/// Saves the given ModelRoot and ClassDiagram to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		public virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, ModelRoot modelRoot, string modelFileName, ClassDiagram diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
		{
			#region Check Parameters
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			if (string.IsNullOrEmpty(modelFileName))
				throw new global::System.ArgumentNullException("modelFileName");
			if (diagram == null)
				throw new global::System.ArgumentNullException("diagram");
			if (string.IsNullOrEmpty(diagramFileName))
				throw new global::System.ArgumentNullException("diagramFileName");
			#endregion
	
			if (serializationResult.Failed)
				return;
	
			// Save the model file first
			using (global::System.IO.MemoryStream modelFileContent = this.InternalSaveModel(serializationResult, modelRoot, modelFileName, encoding, writeOptionalPropertiesWithDefaultValue))
			{
				if (serializationResult.Failed)
					return;
	
				using (global::System.IO.MemoryStream diagramFileContent = this.InternalSaveDiagram(serializationResult, diagram, diagramFileName, encoding, writeOptionalPropertiesWithDefaultValue))
				{
					if (!serializationResult.Failed)
					{
						// Only write the contents if there's no error encountered during serialization.
						if (modelFileContent != null)
						{
							using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(modelFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
							{
								using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
								{
									writer.Write(modelFileContent.ToArray());
								}
							}
						}
						if (diagramFileContent != null)
						{
							using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(diagramFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
							{
								using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
								{
									writer.Write(diagramFileContent.ToArray());
								}
							}
						}
					}
				}
			}
		}
	
		/// <summary>
		/// Saves the given diagram to the given file, with default encoding (UTF-8), and optional properties with default value will not
		/// be written out.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		public virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, ClassDiagram diagram, string diagramFileName)
		{
			this.SaveDiagram(serializationResult, diagram, diagramFileName, global::System.Text.Encoding.UTF8, false);
		}
		
		/// <summary>
		/// Saves the given diagram to the given file, with default encoding (UTF-8).
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		public virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, ClassDiagram diagram, string diagramFileName, bool writeOptionalPropertiesWithDefaultValue)
		{
			this.SaveDiagram(serializationResult, diagram, diagramFileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
		}
	
		/// <summary>
		/// Saves the given ClassDiagram to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		public virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, ClassDiagram diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
		{
			#region Check Parameters
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			if (diagram == null)
				throw new global::System.ArgumentNullException("diagram");
			if (string.IsNullOrEmpty(diagramFileName))
				throw new global::System.ArgumentNullException("diagramFileName");
			#endregion
	
			if (serializationResult.Failed)
				return;
	
			using (global::System.IO.MemoryStream diagramFileContent = this.InternalSaveDiagram(serializationResult, diagram, diagramFileName, encoding, writeOptionalPropertiesWithDefaultValue))
			{
				if (!serializationResult.Failed)
				{
					// Only write the contents if there's no error encountered during serialization.
					if (diagramFileContent != null)
					{
						using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(diagramFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
						{
							using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
							{
								writer.Write(diagramFileContent.ToArray());
							}
						}
					}
				}
			}
		}
	
		/// <summary>
		/// Return the model in XML format
		/// </summary>
		/// <param name="modelRoot">ExampleModel instance to be saved.</param>
		/// <param name="encoding">Encoding to use when saving the ExampleModel instance.</param>
		/// <returns>Model in XML form</returns>
		public virtual string GetSerializedModelString(global::LinqToRdf.Designer.ModelRoot modelRoot, global::System.Text.Encoding encoding)
		{
			string result = string.Empty;
			if (modelRoot == null)
			{
				return result;
			}
	
			DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
			using (global::System.IO.MemoryStream modelFileContent = this.InternalSaveModel(serializationResult, modelRoot, string.Empty, encoding, false))
			{
				if (!serializationResult.Failed && modelFileContent != null)
				{
					char[] chars = encoding.GetChars(modelFileContent.GetBuffer());
	
					// search the open angle bracket and trim off the Byte Of Mark.
					result = new string( chars);
					int indexPos = result.IndexOf('<');
					if (indexPos > 0)
					{
						// strip off the leading Byte Of Mark.
						result = result.Substring(indexPos);
					}
	
					// trim off trailing 0s.
					result = result.TrimEnd( '\0');
				}
			}
			return result;
		}
		
	
		#region Private/Helper Methods/Properties
		/// <summary>
		/// DomainXmlSerializerDirectory instance used by this LinqToRdfDesignerSerializationHelper class.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		/// <summary>
		/// DomainXmlSerializerDirectory instance used by this LinqToRdfDesignerSerializationHelper class.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		protected virtual DslModeling::DomainXmlSerializerDirectory Directory
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				if (this.directory == null)
				{
					this.directory = new DslModeling::DomainXmlSerializerDirectory();
					directory.AddBehavior(DslDiagrams::CoreDesignSurfaceSerializationBehavior.Instance);
					directory.AddBehavior(LinqToRdfDesignerSerializationBehavior.Instance);
				}
				return this.directory;
			}
		}
		
		/// <summary>
		/// This method creates one SimpleMonikerResolver instance for each DomainModel used in serialization.
		/// </summary>
		/// <param name="store">Store on which moniker resolvers will be set up.</param>
		internal protected virtual global::System.Collections.Generic.IDictionary<global::System.Guid, DslModeling::IMonikerResolver> GetMonikerResolvers(DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException("store");
			#endregion
			
			global::System.Collections.Generic.Dictionary<global::System.Guid, DslModeling::IMonikerResolver> result = new global::System.Collections.Generic.Dictionary<global::System.Guid, DslModeling::IMonikerResolver>();
			result.Add(DslDiagrams::CoreDesignSurfaceDomainModel.DomainModelId, new DslDiagrams::CoreDesignSurfaceSerializationBehaviorMonikerResolver(store, this.Directory));
			result.Add(LinqToRdfDesignerDomainModel.DomainModelId, new LinqToRdfDesignerSerializationBehaviorMonikerResolver(store, this.Directory));
			return result;
		}
	
		/// <summary>
		/// Ensure that moniker resolvers are installed properly on the given store, so that deserialization can be carried out correctly.
		/// </summary>
		/// <param name="serializationContext">SerializationContext of the current operations.</param>
		/// <param name="store">Store on which moniker resolvers will be set up.</param>
		protected virtual void SetupMonikerResolver(DslModeling::SerializationContext serializationContext, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException("store");
			#endregion
	
			global::System.Collections.Generic.IDictionary<global::System.Guid, DslModeling::IMonikerResolver> resolvers = this.GetMonikerResolvers(store);
			foreach (global::System.Collections.Generic.KeyValuePair<global::System.Guid, DslModeling::IMonikerResolver> pair in resolvers)
			{
				DslModeling::IMonikerResolver existingMonikerResolver = store.FindMonikerResolver(pair.Key);
				if (existingMonikerResolver == null)
				{
					existingMonikerResolver = pair.Value;
					store.AddMonikerResolver(pair.Key, existingMonikerResolver);
				}
				DslModeling::SimpleMonikerResolver simpleMonikerResolver = existingMonikerResolver as DslModeling::SimpleMonikerResolver;
				if (simpleMonikerResolver != null)
					simpleMonikerResolver.SerializationContext = serializationContext;
			}
		}
		
		#region Class SerializationValidationObserver
		/// <summary>
		/// An utility class to collect validation messages during serialization, and store them in serialization result.
		/// </summary>
		private sealed class SerializationValidationObserver : DslValidation::ValidationMessageObserver, global::System.IDisposable
		{
			#region Member Variables
			/// <summary>
			/// SerializationResult to store the messages.
			/// </summary>
			private DslModeling::SerializationResult serializationResult;
			/// <summary>
			/// ValidationController to get messages from.
			/// </summary>
			private DslValidation::ValidationController validationController;
			#endregion
	
			#region Constructor
			/// <summary>
			/// Constructor
			/// </summary>
			internal SerializationValidationObserver(DslModeling::SerializationResult serializationResult, DslValidation::ValidationController validationController)
			{
				#region Check Parameters
				global::System.Diagnostics.Debug.Assert(serializationResult != null);
				global::System.Diagnostics.Debug.Assert(validationController != null);
				#endregion
	
				this.serializationResult = serializationResult;
				this.validationController = validationController;
	
				// Subscribe to validation messages.
				this.validationController.AddObserver(this);
			}
	
			/// <summary>
			/// Destructor
			/// </summary>
			~SerializationValidationObserver()
			{
				this.Dispose(false);
			}
			#endregion
	
			#region Base Overrides
			/// <summary>
			/// Called with validation messages are added.
			/// </summary>
			protected override void OnValidationMessageAdded(DslValidation::ValidationMessage addedMessage)
			{
				#region Check Parameters
				global::System.Diagnostics.Debug.Assert(addedMessage != null);
				#endregion
	
				if (addedMessage != null && this.serializationResult != null)
				{	// Record the validation message as a serialization message.
					DslModeling::SerializationUtilities.AddValidationMessage(this.serializationResult, addedMessage);
				}
				base.OnValidationMessageAdded(addedMessage);
			}
			#endregion
	
			#region IDisposable Members
			/// <summary>
			/// IDisposable.Dispose().
			/// </summary>
			public void Dispose()
			{
				this.Dispose(true);
				global::System.GC.SuppressFinalize(this);
			}
	
			/// <summary>
			/// Unregister the observer on dispose.
			/// </summary>
			private void Dispose(bool disposing)
			{
				global::System.Diagnostics.Debug.Assert(disposing, "SerializationValidationObserver finalized without being disposed!");
				if (disposing && this.validationController != null)
				{
					this.validationController.RemoveObserver(this);
					this.validationController = null;
				}
				this.serializationResult = null;
			}
			#endregion
		}
		#endregion
		
		/// <summary>
		/// Go through the diagram to find all shapes that are not connected to a model element. Some of them may be by design, the rest are out-of-sync shapes.
		/// We want to make sure that all out-of-sync shapes are given a chance to fix themselves up, or post proper warning/error messages.
		/// </summary>
		/// <param name="diagram">The diagram of which the shapes are being checked.</param>
		/// <param name="serializationResult">SerializationResult to store warning/error in case an orphaned shape choose to do so.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
		protected virtual void CheckForOrphanedShapes(DslDiagrams::Diagram diagram, DslModeling::SerializationResult serializationResult)
		{
			global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes = new global::System.Collections.Generic.List<DslDiagrams::ShapeElement>();
			diagram.IterateShapes(new OrphanedShapeIterator(orphanedShapes, diagram));
			foreach (DslDiagrams::ShapeElement orphanedShape in orphanedShapes)
			{
				if (serializationResult.Failed)
					break;
	
				orphanedShape.OnOrphaned(serializationResult);
			}
		}
		
		#region Class OrphanedShapeIterator
		/// <summary>
		/// An iterator to collect all the orphaned shapes.
		/// </summary>
		private class OrphanedShapeIterator : DslDiagrams::IShapeIterator
		{
			#region Member Variables
			/// <summary>
			/// Stores all iterated orphaned shapes.
			/// </summary>
			private global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes;
			
			/// <summary>
			/// Diagram that contains the shapes to be iterated.
			/// </summary>
			private DslDiagrams::Diagram diagram;
			#endregion
	
			#region Constructor
			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="orphanedShapes">Storage for all iterated orphaned shapes.</param>
			/// <param name="diagram">Diagram that contains the shapes to be iterated.</param>
			internal OrphanedShapeIterator(global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes, DslDiagrams::Diagram diagram)
			{
				#region Check Parameters
				global::System.Diagnostics.Debug.Assert(orphanedShapes != null);
				global::System.Diagnostics.Debug.Assert(diagram != null);
				#endregion
	
				this.orphanedShapes = orphanedShapes;
				this.diagram = diagram;
			}
			#endregion
	
			#region IShapeIterator Members
			/// <summary>
			/// Called when a shape is encountered during iteration. The shape will be stored if it's orphaned.
			/// A shape is considered "orphaned" if:
			/// 1) It has a PresentationViewsSubject link out of it, but the Subject cannot be resolved.
			/// 2) It is a connector, and the Subject is null (regardless of the existence of PresentationViewsSubject relationship).
			/// </summary>
			/// <param name="shape">Shape encountered.</param>
			public void OnShape(DslDiagrams::ShapeElement shape)
			{
				if (this.diagram.IsOrphaned(shape))
					this.orphanedShapes.Add(shape);	// Orphaned.
			}
			#endregion
		}
		#endregion
		#endregion
	}
	
	/// <summary>
	/// Helper class for serializing and deserializing LinqToRdfDesigner models.
	/// </summary>
	public sealed partial class LinqToRdfDesignerSerializationHelper : LinqToRdfDesignerSerializationHelperBase
	{
		#region Constructor
		/// <summary>
		/// Private constructor to prevent direct instantiation.
		/// </summary>
		private LinqToRdfDesignerSerializationHelper() : base () { }
		#endregion
		
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static LinqToRdfDesignerSerializationHelper instance;
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static LinqToRdfDesignerSerializationHelper Instance
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				if (LinqToRdfDesignerSerializationHelper.instance == null)
					LinqToRdfDesignerSerializationHelper.instance = new LinqToRdfDesignerSerializationHelper();
				return LinqToRdfDesignerSerializationHelper.instance;
			}
		}
		#endregion
	}
}

namespace LinqToRdf.Designer
{
	[DslValidation::ValidationState(DslValidation::ValidationState.Enabled)]
	public partial class ModelRoot
	{
		/// <summary>
		/// Check to make sure all elements in the model will have unambiguous monikers when serialized.
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Generated code.")]
		[DslValidation::ValidationMethod(DslValidation::ValidationCategories.Load | DslValidation::ValidationCategories.Menu)]
		private void ValidateMonikerAmbiguity(DslValidation::ValidationContext context)
		{
			global::System.Collections.Generic.IDictionary<global::System.Guid, DslModeling::IMonikerResolver> monikerResolvers = LinqToRdfDesignerSerializationHelper.Instance.GetMonikerResolvers(this.Store);
			foreach (DslModeling::ModelElement element in this.Store.ElementDirectory.AllElements)
			{
				global::System.Guid domainModelId = element.GetDomainClass().DomainModel.Id;
				DslModeling::IMonikerResolver monikerResolver = null;
				if (monikerResolvers.TryGetValue(domainModelId, out monikerResolver) && monikerResolver != null)
				{
					DslModeling::SimpleMonikerResolver simpleMonikerResolver = monikerResolver as DslModeling::SimpleMonikerResolver;
					if (simpleMonikerResolver != null)
					{
						try
						{
							simpleMonikerResolver.ProcessAddedElement(element);
						}
						catch (DslModeling::AmbiguousMonikerException amEx)
						{	// Ambiguous moniker detected.
							context.LogError(
								string.Format(
									global::System.Globalization.CultureInfo.CurrentCulture,
									LinqToRdfDesignerDomainModel.SingletonResourceManager.GetString("AmbiguousMoniker"),
									amEx.Moniker,
									DslModeling::SerializationUtilities.GetElementName(element),
									DslModeling::SerializationUtilities.GetElementName(amEx.Element)
								),
								"AmbiguousMoniker", 
								this,
								amEx.Element
							);
						}
					}
				}
			}
			// Clean up the created moniker resolvers after the check.
			foreach (DslModeling::IMonikerResolver monikerResolver in monikerResolvers.Values)
			{
				DslModeling::SimpleMonikerResolver simpleMonikerResolver = monikerResolvers as DslModeling::SimpleMonikerResolver;
				if (simpleMonikerResolver != null)
					simpleMonikerResolver.Dispose();
			}
			monikerResolvers.Clear();
		}
	}
}
